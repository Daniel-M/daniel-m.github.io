<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Daniel Mejía Raigosa</title>
    <link>https://daniel-m.github.io/post/</link>
    <description>Recent content in Posts on Daniel Mejía Raigosa</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2018 Daniel Mejía R.</copyright>
    <lastBuildDate>Sun, 01 Jan 2017 00:00:00 -0500</lastBuildDate>
    <atom:link href="/post/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ESP32: esp-idf Development Framework and the FreeRTOS kernel</title>
      <link>https://daniel-m.github.io/post/2018/nov/esp32/esp32-3_words_freertos/</link>
      <pubDate>Sat, 10 Nov 2018 00:40:25 -0500</pubDate>
      
      <guid>https://daniel-m.github.io/post/2018/nov/esp32/esp32-3_words_freertos/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://daniel-m.github.io/post/2018/oct/esp32/esp32-1_getting_started/&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;This post is part of a series of ESP32 blog posts. Look the index here&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;motivation&#34;&gt;Motivation&lt;/h2&gt;

&lt;p&gt;In &lt;a href=&#34;https://daniel-m.github.io/post/2018/oct/esp32/esp32-2-setting_up_development_environment/&#34; target=&#34;_blank&#34;&gt;the last blog post&lt;/a&gt;
we saw how to set up the basic development environment, then build and loaded
a &lt;code&gt;hello-world&lt;/code&gt; program included in the examples folder of the esp-idf (Espressif IoT
Development Framework). Today I&amp;rsquo;ll try to give some details about what is actually
happening in the process, about what is the operating system running within the
ESP32, and how it works.&lt;/p&gt;

&lt;h2 id=&#34;the-application-development&#34;&gt;The application development&lt;/h2&gt;

&lt;p&gt;The application development may be summarized in four steps:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Configuration of a Project and writing the code&lt;/li&gt;
&lt;li&gt;Compilation of the Project and linking it to build an Application&lt;/li&gt;
&lt;li&gt;Flashing (uploading) of the Application to ESP32&lt;/li&gt;
&lt;li&gt;Monitoring / debugging of the Application as needed&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The following diagram depicts the ESP32 application development,&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://docs.espressif.com/projects/esp-idf/en/latest/_images/what-you-need.png&#34; alt=&#34;Depiction of the development of ESP32 applications&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;configuration-of-the-project&#34;&gt;Configuration of the project&lt;/h2&gt;

&lt;p&gt;The esp-idf provides &lt;a href=&#34;https://github.com/espressif/esp-idf-template&#34; target=&#34;_blank&#34;&gt;a project template&lt;/a&gt;
which can be used to bootstrap a new project. The source tree has,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A Makefile which defines the name for the project (&lt;code&gt;app-template&lt;/code&gt; in the
template), that also imports a Makefile from the esp-idf location, which is
expected to be set at &lt;code&gt;IDF_PATH&lt;/code&gt; &lt;a href=&#34;https://daniel-m.github.io/post/2018/oct/esp32/esp32-2-setting_up_development_environment/&#34; target=&#34;_blank&#34;&gt;as we did in the last blog&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;A &lt;code&gt;main&lt;/code&gt; path which contains,&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;main.c&lt;/code&gt; - The actual source code for our application&lt;/li&gt;
&lt;li&gt;&lt;code&gt;component.mk&lt;/code&gt; - Component specific makefile. We&amp;rsquo;ll leave this empty for
now&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The programming language of choice is C, though C++ and even assembly also can be used.
As mentioned &lt;a href=&#34;https://daniel-m.github.io/post/2018/nov/esp32/esp32-2-setting_up_development_environment/&#34; target=&#34;_blank&#34;&gt;in an earlier blog post&lt;/a&gt; we can use other bootloaders that could allow us to
program ESP&amp;rsquo;s with Python or Lua among others.&lt;/p&gt;

&lt;p&gt;To write an application using the espressif template &amp;ndash;which I do recommend&amp;ndash; you&amp;rsquo;ll
need to edit the file &lt;code&gt;src/main.c&lt;/code&gt;. Another approach is to make a copy of the &lt;code&gt;hello-world&lt;/code&gt;
located at &lt;code&gt;$IDF_PATH/examples/get-started/hello_world&lt;/code&gt; and build upon it.&lt;/p&gt;

&lt;p&gt;Once you have some code, yo can compile it and upload it to the ESP32.
&lt;a href=&#34;https://daniel-m.github.io/post/2018/oct/esp32/esp32-2-setting_up_development_environment/&#34; target=&#34;_blank&#34;&gt;As we saw in the last blog post&lt;/a&gt;
with the esp-idf we can use the Makefile, and perform the compilation with
&lt;code&gt;make&lt;/code&gt;. This won&amp;rsquo;t upload the code, but it will &lt;em&gt;cross compile&lt;/em&gt; it &amp;ndash;more about
his below&amp;ndash; to run on ESP32
CPUs. If the compilation succeeds we can upload the application to the ESP32
with &lt;code&gt;make flash&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Cross compiling&lt;/em&gt; is the process of using a host computer architecture to compile
binaries targeted to run in another architecture. For the ESP32, I use my &lt;code&gt;amd64&lt;/code&gt; 64-bit
architecture to compile programs for the Xtensa Tensilica LX6 Microprocessor,
which is a 32-bit architecture. That&amp;rsquo;s why we need a toolchain since it
provides an adequate set of cross compiling tools and library linkers to put
together machine code that can run on the ESP&amp;rsquo;s 32-bit CPU.&lt;/p&gt;

&lt;p&gt;The toolchain contains several commands with the form &lt;code&gt;xtensa-esp32-elf-*&lt;/code&gt;, for
instance, &lt;code&gt;xtensa-esp32-elf-gcc&lt;/code&gt; is the C compiler to build Xtensa binaries
that run on ESP32 CPUs.&lt;/p&gt;

&lt;p&gt;In summary, the esp-idf with the toolchain allows to build an upload the application to the
ESP32.&lt;/p&gt;

&lt;h3 id=&#34;compilation-flashing-and-monitoring-of-the-project&#34;&gt;Compilation flashing and Monitoring of the project&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://daniel-m.github.io/post/2018/oct/esp32/esp32-2-setting_up_development_environment/&#34; target=&#34;_blank&#34;&gt;We have already seen&lt;/a&gt; how to compile the project, flash it to the ESP32, and
how to look to the serial monitor, all with the esp-idf. If you wish to get a
deeper understanding, I suggest reading more at the amazing &lt;a href=&#34;https://leanpub.com/kolban-ESP32&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;Kolban&amp;rsquo;s book on ESP32&lt;/em&gt; by Neil Kolban&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;freertos&#34;&gt;FreeRTOS&lt;/h2&gt;

&lt;p&gt;The purpose of an operating system kernel
is to provide an interface between the software applications and the underlying
hardware infrastructure. When we are running ESP32 programs, we are doing so
within the FreeRTOS kernel.&lt;/p&gt;

&lt;p&gt;The FreeRTOS is an open source operating system designed for embedded systems like the ESP32, it has
three main core functions,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Memory management&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Task management&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;API Synchronization&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The RTOS stands for Real Time Operating System, a property that we will discuss
in the next subsection.&lt;/p&gt;

&lt;p&gt;The FreeRTOS kernel was originally developed by Richard Barry around 2003, after years of development and success, Amazon Web Services (AWS) took over the stewardship of the project in 2017. It is natural to ask, why did AWS asume this role?, well AWS offers services to millions of customers, and in all industry sectors.
A growing number of AWS services are designed for Internet of Things (IoT) applications, that is, the connection and management of internet connected devices.&lt;/p&gt;

&lt;p&gt;Device manufacturers connect their MCU based devices to the cloud, however, it takes time to build the security and connectivity components necessary for those devices run work properly at production scale. A significant proportion of connected MCU devices already run the FreeRTOS kernel, so Amazon chose to provide the FreeRTOS project with the resources necessary to extend their offering into fully integrated security and connectivity libraries, and ensure those libraries can be developed and supported long into the future.&lt;/p&gt;

&lt;h3 id=&#34;memory-management&#34;&gt;Memory management&lt;/h3&gt;

&lt;p&gt;Since we are working with C, the use of &lt;code&gt;malloc()&lt;/code&gt; and &lt;code&gt;free()&lt;/code&gt; are valid ways
to allocate or release memory resources, like in the example below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;stdlib.h&amp;gt;

int main() {
    // Allocate memory for an Int
    int *counter = malloc(sizeof(int));
    
    // Store data in the variable
    *counter = 123;
    
    // Print what we have
    printf(&amp;quot;Variable contents: %i\n&amp;quot;, *counter);
    
    // Release the memory
    free(counter);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;task-management&#34;&gt;Task management&lt;/h3&gt;

&lt;p&gt;A part of the operating system called the scheduler is responsible for deciding
which program to run when, and provides the illusion of simultaneous execution
by rapidly switching between each program.&lt;/p&gt;

&lt;p&gt;The scheduler in FreeRTOS is designed to provide a predictable &amp;ndash;deterministic&amp;ndash;
execution pattern. This is critical to embedded systems since they often have
real time requirements, tha is, the embedded system must respond to a certain
event within a strictly defined time.&lt;/p&gt;

&lt;p&gt;Traditional real time schedulers, such as the scheduler used in FreeRTOS,
achieve determinism &amp;ndash;hence predictability&amp;ndash; by allowing the user to assign a
priority to each thread of execution.
The scheduler then uses the priority to know which thread of execution to run
next. In FreeRTOS, a thread of execution is called a &lt;em&gt;task&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;task&lt;/em&gt; can be intuitively understood as any piece of work that can be performed by the CPU.
Examples of tasks could be checking whether a voltage level changes at certain GPIO port
&amp;ndash;say, by pressing a button&amp;ndash;, or making a led blink by setting the voltage of
the associated GPIO from low to high and back to low at certain frequency.&lt;/p&gt;

&lt;p&gt;FreeRTOS allows several tasks to run concurrently by switching between task
executions in a non locking fashion. In other words, the kernel can sequentially
execute portions of different tasks at consecutive CPU cycles. The
following image depicts this behaviour,&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.freertos.org/implementation/TaskExecution.gif&#34; alt=&#34;FreeRTOS concurrent task execution&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Each horizontal line represents a task. In the top part of the image, the tasks
seem to run at the same time, but as the portion at the bottom show, only a task
at the time is executed by the CPU.&lt;/p&gt;

&lt;p&gt;In FreeRTOS a &lt;code&gt;task&lt;/code&gt; is implemented by a code block responsible of performing
whatever the task we&amp;rsquo;d like to perform, but with a function signature as,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void theTaskName(void *theParameters)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But this is not enough, the task must be created with &lt;code&gt;xTaskCreate()&lt;/code&gt; &amp;ndash;we well
discuss this API in detail in a future blog post&amp;ndash;.&lt;/p&gt;

&lt;p&gt;FreeRTOS expects a task to run forever, but, if we need it to end, we need to
call &lt;code&gt;vTaskDelete()&lt;/code&gt; at the end of the scope of the task code block, like this,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void theTaskName(void *theParameters) {

  // Perform activities

  vTaskDelete(NULL);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;ll go into details about creating task in a following blog post.&lt;/p&gt;

&lt;h3 id=&#34;api-synchronization&#34;&gt;API Synchronization&lt;/h3&gt;

&lt;p&gt;This is a more advanced topic of ESP32 programming with FreeRTOS, I&amp;rsquo;m still
pending of diving into it and writing about it here.&lt;/p&gt;

&lt;h2 id=&#34;application-entry-point&#34;&gt;Application entry point&lt;/h2&gt;

&lt;p&gt;If you look at the code of the &lt;code&gt;hello-world&lt;/code&gt; example, you&amp;rsquo;ll notice that, unlike
a regular C program, we have no &lt;code&gt;main()&lt;/code&gt; function. The application entry for the
esp-idf + FreeRTOS is the &lt;code&gt;app_main()&lt;/code&gt; function. This doesn&amp;rsquo;t mean we can&amp;rsquo;t
define more functions, as I wrote above, we can create FreeRTOS task and such.
Programming the ESP32 with esp-idf is really regular C programming. Before
running the entry point function, several steps happen, I recommend reading
&lt;a href=&#34;https://docs.espressif.com/projects/esp-idf/en/stable/get-started/&#34; target=&#34;_blank&#34;&gt;Espressif esp-idf getting started&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog I&amp;rsquo;ve discussed how the esp-idf helps us to program ESP32 CPUs,
and what is actually running within our ESP32 device, besides a very basic
notion of what is a task, a concept we will be using a lot in the following blog
posts&lt;/p&gt;

&lt;h2 id=&#34;resources&#34;&gt;Resources&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.espressif.com/projects/esp-idf/en/stable/get-started/&#34; target=&#34;_blank&#34;&gt;Espressif esp-idf getting started&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/general-notes.html&#34; target=&#34;_blank&#34;&gt;General Notes About ESP-IDF Programming&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.freertos.org/about-RTOS.html&#34; target=&#34;_blank&#34;&gt;https://www.freertos.org/about-RTOS.html&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ESP32: Setting up a development environment</title>
      <link>https://daniel-m.github.io/post/2018/oct/esp32/esp32-2-setting_up_development_environment/</link>
      <pubDate>Sun, 28 Oct 2018 20:40:25 -0500</pubDate>
      
      <guid>https://daniel-m.github.io/post/2018/oct/esp32/esp32-2-setting_up_development_environment/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://daniel-m.github.io/post/2018/oct/esp32/esp32-1_getting_started/&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;This post is part of a series of ESP32 blog posts. Look the index here&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;introduction-sort-of&#34;&gt;Introduction (sort of)&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&#34;https://www.espressif.com/en/products/hardware/esp32&#34; target=&#34;_blank&#34;&gt;ESP32&lt;/a&gt; was originally conceived by
&lt;a href=&#34;https://www.espressif.com/&#34; target=&#34;_blank&#34;&gt;espressif&lt;/a&gt; a multinational company with
headquarters in Shangai, focused on developing cutting-edge WiFi-and-Bluetooth,
low-power, IoT solutions. Among our popular products are the ESP8266 and ESP32
series of chips, modules and development boards.&lt;/p&gt;

&lt;p&gt;The ESP32 can be programmed in several ways, among the languages and platforms
supported the most popular are,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://micropython.org&#34; target=&#34;_blank&#34;&gt;MicroPython&lt;/a&gt; a python implementation for embedded
systems.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.arduino.cc/en/Main/Software&#34; target=&#34;_blank&#34;&gt;Arduino IDE&lt;/a&gt; the IDE for Arduino
platforms.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.nodemcu.com/&#34; target=&#34;_blank&#34;&gt;NodeMCU&lt;/a&gt; a platform to program embedded systems
using Lua.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://platformio.org/platformio-ide&#34; target=&#34;_blank&#34;&gt;PlatformIO&lt;/a&gt; a project which aims to
provide an unified development tool for embedded systems.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/espressif/esp-idf&#34; target=&#34;_blank&#34;&gt;Espressif esp-idf&lt;/a&gt; Espressif IoT Development Framework. Official development framework for ESP32. I&amp;rsquo;ll be using this.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;getting-a-working-espressif-esp-idf-environment&#34;&gt;Getting a working Espressif esp-idf environment&lt;/h2&gt;

&lt;p&gt;This part is based on &lt;a href=&#34;https://docs.espressif.com/projects/esp-idf/en/stable/get-started/&#34; target=&#34;_blank&#34;&gt;the official instructions by espressif&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The installation process consists of two steps,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Setting up the toolchain.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Setting up the Espressif esp-idf from github.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To get the esp-idf, head to &lt;a href=&#34;https://github.com/espressif/esp-idf&#34; target=&#34;_blank&#34;&gt;https://github.com/espressif/esp-idf&lt;/a&gt;,
click the &lt;code&gt;releases&lt;/code&gt; button and download the latest release available.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./idf-releases.png&#34; alt=&#34;IDF releases&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now install some prerequisites to the build process,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install gcc git wget make libncurses-dev flex bison gperf python python-serial
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, a recommended place to install the esp-idf is the path &lt;code&gt;$HOME/opt/esp&lt;/code&gt;. In
order to simplify the install process, declare the following variable,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export ESP_PATH=$HOME/opt/esp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And create the required destination directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir $ESP_PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;getting-the-toolchain&#34;&gt;Getting the toolchain&lt;/h3&gt;

&lt;p&gt;The toolchain can be obtained by one of two ways,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Building from source. This allows to have a custom toolchain if some
configurations are set.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Using a precompiled toolchain. This approach is more restrictive, but
straightforward.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I&amp;rsquo;ve tried both approaches, and found that the later is the simplest way to get
a working toolchain.&lt;/p&gt;

&lt;p&gt;There are OS specific instructions for &lt;a href=&#34;https://docs.espressif.com/projects/esp-idf/en/v3.1/get-started/windows-setup.html&#34; target=&#34;_blank&#34;&gt;Windows&lt;/a&gt;,
&lt;a href=&#34;https://docs.espressif.com/projects/esp-idf/en/v3.1/get-started/linux-setup.html&#34; target=&#34;_blank&#34;&gt;Linux&lt;/a&gt;,
and &lt;a href=&#34;https://docs.espressif.com/projects/esp-idf/en/v3.1/get-started/macos-setup.html&#34; target=&#34;_blank&#34;&gt;MacOS&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As the time of writing this blog, the latest precompiled toolchain could be
obtained in Linux by running,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd $ESP_PATH
wget https://dl.espressif.com/dl/xtensa-esp32-elf-linux64-1.22.0-80-g6c4433a-5.2.0.tar.gz
tar xvfz xtensa-esp32-elf-linux64-1.22.0-80-g6c4433a-5.2.0.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, add the toolchain to the &lt;code&gt;$PATH&lt;/code&gt;,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export PATH=&amp;quot;$PATH:$HOME/opt/esp/xtensa-esp32-elf/bin&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;getting-the-esp-idf&#34;&gt;Getting the ESP-IDF&lt;/h3&gt;

&lt;p&gt;First, we need to define an environment variable pointing to the destination
of the esp-idf&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export IDF_PATH=$ESP_PATH/esp-idf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can head there and get the latest version of the esp-idf from github&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd $ESP_PATH
git clone -b v3.1 --recursive https://github.com/espressif/esp-idf.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can replace &lt;code&gt;v3.1&lt;/code&gt; with the latest tag available in the repository. Now, to
bootstrap the repository,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd $IDF_PATH
git submodule update --init --recursive
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The currently logged user should have read and write access the serial port over USB.
On most Linux distributions, this is done by adding the user to &lt;code&gt;dialout&lt;/code&gt; group
with the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo usermod -a -G dialout $USER
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Make sure you re-login to the shell in order to the changes to take effect
(there are other ways to achieve this, but maybe the most universal way is a
simple logout)&lt;/p&gt;

&lt;p&gt;To test the installation you can run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xtensa-esp32-elf-gcc --version
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;testing-serial-communications&#34;&gt;Testing serial communications&lt;/h2&gt;

&lt;p&gt;A bunch of blog posts cover the ways in which we can read and write to a serial
port in linux. For example, &lt;a href=&#34;https://www.cyberciti.biz/hardware/5-linux-unix-commands-for-connecting-to-the-serial-console/&#34; target=&#34;_blank&#34;&gt;this blog post shows several options&lt;/a&gt;. In linux systems a way
to detect the serial port used by our device is to list the contents of the
tty&amp;rsquo;s available under &lt;code&gt;/dev&lt;/code&gt; with &lt;code&gt;ls /dev/tty*&lt;/code&gt;, then connect the ESP32 with
the USB cable and list &lt;code&gt;ls /dev/tty*&lt;/code&gt; again. You&amp;rsquo;ll notice that a new element
appears with the name &lt;code&gt;/dev/ttyS0&lt;/code&gt; or &lt;code&gt;/dev/ttyUSB0&lt;/code&gt; (or any other number like
ttyUSB1, depending on your particular hardware and linux distribution).&lt;/p&gt;

&lt;h3 id=&#34;picocom&#34;&gt;Picocom&lt;/h3&gt;

&lt;p&gt;Picocom is a minimal terminal emulator which can be connected to the serial
port. To get it installed just run,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install picocom
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Connect the ESP32. If it is connected to the &lt;code&gt;/dev/ttyUSB0&lt;/code&gt; serial port, you can
check the connection with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;picocom /dev/ttyUSB0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;esp-idf-monitor&#34;&gt;esp-idf monitor&lt;/h3&gt;

&lt;p&gt;esp-idf comes with a serial monitor which can be run with &lt;code&gt;make monitor&lt;/code&gt; under
a project&amp;rsquo;s directory.&lt;/p&gt;

&lt;p&gt;The simplest way to check that everything is properly installed is to burn the
&lt;code&gt;hello world&lt;/code&gt; included with the esp-idf,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd $IDF_PATH/examples/get-started/hello_world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This compiles the program. To load it to the ESP32, connect it with the USB
cable and run,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make flash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which will take care of everything.&lt;/p&gt;

&lt;p&gt;To check the actual &lt;code&gt;hello world&lt;/code&gt;, wait until the load is completed and either run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;picocom /dev/ttyUSB0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make monitor # from within the hello-world proyect folder
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should see something like this,&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./hello-world-esp32.png&#34; alt=&#34;The hello-world&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The messages shown will be different, according to your particular hardware.&lt;/p&gt;

&lt;p&gt;You can use &lt;code&gt;picocom /dev/ttyUSB0&lt;/code&gt; and see the messages similarly, but I rather
use &lt;code&gt;make monitor&lt;/code&gt; since it is faster to type.&lt;/p&gt;

&lt;p&gt;Well, that&amp;rsquo;s about it, you got the official espressif-idf development
environment ready to use in your system.&lt;/p&gt;

&lt;h2 id=&#34;resources&#34;&gt;Resources&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.espressif.com/projects/esp-idf/en/stable/get-started/&#34; target=&#34;_blank&#34;&gt;Espressif esp-idf getting started&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Getting started with the ESP32</title>
      <link>https://daniel-m.github.io/post/2018/oct/esp32/esp32-1_getting_started/</link>
      <pubDate>Sun, 28 Oct 2018 19:42:25 -0500</pubDate>
      
      <guid>https://daniel-m.github.io/post/2018/oct/esp32/esp32-1_getting_started/</guid>
      <description>

&lt;h2 id=&#34;motivation&#34;&gt;Motivation&lt;/h2&gt;

&lt;p&gt;One of my hobbies during my school days was electronics after learning about
&lt;a href=&#34;https://en.wikipedia.org/wiki/BEAM_robotics&#34; target=&#34;_blank&#34;&gt;B.E.A.M&lt;/a&gt; robots during a &lt;em&gt;Popular
Mechanics for Kids&lt;/em&gt; episode. &lt;a href=&#34;http://solarbotics.net/&#34; target=&#34;_blank&#34;&gt;You can learn more about B.E.A.M. here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;During my University years I had the opportunity to refine my knowledge on basic
electronics, and exploit my programming skills programming Arduino and Microchip
microcontrollers (a.k.a MCUs). Those where days filled with fun, but I still
wanted to be able to send data to remote locations, which could be possible by
means of a RaspberryPI, or a GSM module or Bluetooth module &amp;ndash;which were expensive&amp;ndash;
or having the Arduino/MCU connected to a regular computer with internet,
so the whole point of &lt;em&gt;small&lt;/em&gt; devices was not really possible at that time
in terms of a good efficiency/cost relation.&lt;/p&gt;

&lt;p&gt;After several years without doing electronics, I&amp;rsquo;ve heard about the ESP8266 chip
and its predecessor the ESP32. The most appealing feature of those chips
was the built-in support for Wi-Fi or Bluetooth technologies, all shipped in
convenient development boards which can be programmed either with C, Python, or Lua.&lt;/p&gt;

&lt;p&gt;I got lured by the possibilities of having remote controlled electronics and bought
an ESP32 development board. As I progress in learning how to use it, I&amp;rsquo;ll blog about
my experiences getting this new toy up and running, the pitfalls I ran into and
how I manage to solve them.&lt;/p&gt;

&lt;p&gt;As I publish blog entries, they will be linked in the table of contents near the
end of this blog post.&lt;/p&gt;

&lt;h2 id=&#34;but-what-exactly-is-an-esp32&#34;&gt;But what exactly is an ESP32?&lt;/h2&gt;

&lt;p&gt;The ESP32 is a low-cost, low-power system on a chip (SoC) series with Wi-Fi and
dual-mode Bluetooth capabilities, powered by a single or dual core Tensilica
Xtensa LX6 microprocessor with a clock rate of up to 240 MHz. Yes, a tiny chip
with the clock rate of an old
&lt;a href=&#34;https://en.wikipedia.org/wiki/Pentium_II&#34; target=&#34;_blank&#34;&gt;Intel Pentium II CPU&lt;/a&gt;, shipped with
Wi-Fi and Bluetooth. The availability of two ADC channels and more than 15
General purpose Input Output pins (GPIO), makes this chip really powerful to IoT
applications.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how my ESP32 &amp;ndash;based on the &lt;a href=&#34;https://docs.zerynth.com/latest/official/board.zerynth.doit_esp32/docs/index.html&#34; target=&#34;_blank&#34;&gt;doit ESP32 Devkit v1&lt;/a&gt;&amp;ndash; came,&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;esp32_2.jpg&#34; alt=&#34;New toy ESP32&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;esp32_1.jpg&#34; alt=&#34;New toy ESP32 other view&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A sneak peak of what is comming,&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;blinker.gif&#34; alt=&#34;Blinking&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;table-of-contents&#34;&gt;Table of Contents&lt;/h2&gt;

&lt;p&gt;The following blogs are related to ESP32&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://daniel-m.github.io/post/2018/nov/esp32/esp32-2-setting_up_development_environment/&#34; target=&#34;_blank&#34;&gt;Setting up a development environment&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;resources&#34;&gt;Resources&lt;/h2&gt;

&lt;p&gt;Some useful resources are available at,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://esp32.net/&#34; target=&#34;_blank&#34;&gt;http://esp32.net/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lucadentella.it/en/category/esp32&#34; target=&#34;_blank&#34;&gt;Luca Dentella&amp;rsquo;s blog series on ESP32&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The amazing book &lt;a href=&#34;https://leanpub.com/kolban-ESP32&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;Kolban&amp;rsquo;s book on ESP32&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Alternative blog at http://blog.parallelo.ai</title>
      <link>https://daniel-m.github.io/post/2018/oct/alternative-blog/</link>
      <pubDate>Wed, 17 Oct 2018 12:23:57 -0500</pubDate>
      
      <guid>https://daniel-m.github.io/post/2018/oct/alternative-blog/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m not of an active blogger in this site, but you can take a look at
&lt;strong&gt;&lt;a href=&#34;http://blog.parallelo.ai&#34; target=&#34;_blank&#34;&gt;http://blog.parallelo.ai&lt;/a&gt;&lt;/strong&gt; and get in touch with
some of my work-related blog posts.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Old Blog</title>
      <link>https://daniel-m.github.io/post/2017/old-blog/</link>
      <pubDate>Mon, 01 Jan 2018 06:32:12 -0500</pubDate>
      
      <guid>https://daniel-m.github.io/post/2017/old-blog/</guid>
      <description>

&lt;h1 id=&#34;daniel-s-log-book&#34;&gt;Daniel&amp;rsquo;s log book&lt;/h1&gt;

&lt;p&gt;The site &lt;a href=&#34;https://dalogbook.blogspot.com/&#34; target=&#34;_blank&#34;&gt;https://dalogbook.blogspot.com/&lt;/a&gt; is my old blog, which I haven&amp;rsquo;t updated
since forever. Nevertheless I have lots of drafts soon to be published so stay tuned for updates.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
